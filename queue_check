#!/usr/bin/env python
"""A tool to determine errors in compliance with:
https://sites.google.com/a/pdx.edu/oit-cis/cis/policies/cis-operations-policy
"""

import argparse
import logging
import yaml
from getpass import getuser
from time import strptime, strftime, localtime, mktime
from datetime import datetime, date, timedelta
from termcolor import colored
from os import path

import rtclient

RT_URL = "https://example.com/NoAuth-REST/1.0"
RT_SEARCH_TIME = "%Y-%m-%d %H:%M:%S"
NOW = date.strftime(datetime.now(), RT_SEARCH_TIME)
TICKET_TIME = '%a %b %d %H:%M:%S %Y'

class Ticket(object):
    adj2needs = {
                'created': 'needs update from {0.queue} POC',
                'updated': 'needs checkin from customer or {0.queue} POC',
                }

    def __init__(self, ticket_id, creds, url):
        self.ticket_id = ticket_id
        self.ticket_dict = rtclient.get(ticket_id, creds, url)
        
        # copy the pertinent details up a level
        self.created = self.ticket_dict['Created']
        self.queue   = self.ticket_dict['Queue']
        self.status  = self.ticket_dict['Status']
        self.subject = self.ticket_dict['Subject']
        self.updated = self.ticket_dict['LastUpdated']
        for timetype in ['updated', 'created']:
            time = getattr(self, timetype)
            time = mktime(strptime(time, TICKET_TIME))
            setattr(self, timetype, datetime.fromtimestamp(time))

    def __str__(self):
        return '{0.ticket_id}: {0.subject}'.format(self)

    def health(self, policy):
        try:
            # our own copy of the policy!
            state_policy = policy[self.status.lower()].copy()
        except KeyError:
            logging.info("No '{0.status}' policy specified, skipping.".format(self))
            return None

        # what standard are we holding this ticket to?
        activity_attr, speeds = state_policy.popitem()
        last_active = getattr(self, activity_attr)
        fast, slow = [timedelta(hours=speeds[n]) for n in speeds.iterkeys()]
        deadline = last_active + slow
        needs = self.adj2needs[activity_attr].format(self)
        details = (self, deadline, needs)
        ticktxt = colored("rt#{0.ticket_id} ", 'white', attrs=['bold'])
        needs = colored('{2}', 'white')
        if deadline > datetime.now():
            status = colored("On Time {1}: ", 'green')
        else:
            needs = colored('{2}', 'magenta', attrs=['underline'])
            status = colored("Overdue {1}: ", 'red')
        msg = status + ticktxt + needs
        return msg.format(*details)

def check(param_path, who=False):
    logging.debug('Opening: %s, uid=%s', param_path, who)
    with open(param_path, 'rb') as param_file:
        config = yaml.load(param_file)
   
    if who:
        who_query = ' AND Owner = "{}"'.format(who)
    else:
        who_query = ''

    for queue in config['queues']:
        # get all the non-exempt tickets from all queues
        query = "Queue = '{0}' AND Status != 'resolved' AND Status != 'rejected'{1}".format(queue, who_query)
        logging.info('Running query: %s', query)
        for ticket in rtclient.search(query, config['creds'], config['url']):
            logging.info('Got ticket=%s subject="%s"', *ticket)
            ticket_n, _ = ticket
            aticket = Ticket(ticket_n, config['creds'], config['url'])
            ticket_health = aticket.health(config['states'])
            if ticket_health:
                print ticket_health

def main():
    parser = argparse.ArgumentParser(description=__doc__)

    # default config path
    default_config = path.join(path.curdir, 'config.yaml')
    parser.add_argument('-p', '--paramfile', dest='param_path',
                        default=default_config,
                        help="Parameter file, default: %(default)s")

    parser.add_argument('-v', dest='verbosity', action='store_const',
                        const=logging.INFO, help='Verbose.')
    parser.add_argument('-vv', dest='verbosity', action='store_const',
                        const=logging.DEBUG, help='Very verbose.')

    who = parser.add_mutually_exclusive_group()
#    who.add_argument('--everyone', dest='who', action='store_false',
#        help='Check tickets owned by everyone.')
    who.add_argument('--me', dest='who', action='store_const', const=getuser(),
        help='Check tickets owned by %(const)s')
    who.add_argument('--who', dest='who', action='store', default='Nobody',
        help='Examine tickets owned by someone, default: %(default)s')
    
    args = parser.parse_args()
    
    logging.basicConfig(
        format='[%(levelname)s] %(asctime)s: %(message)s',
        level=args.verbosity
    )

    check(args.param_path, args.who)

if __name__ == "__main__":
    main()
