#!/usr/bin/env python
"""A tool to determine errors in compliance with:
https://sites.google.com/a/pdx.edu/oit-cis/cis/policies/cis-operations-policy
"""

import argparse
import logging
import yaml
from getpass import getuser
from time import strptime, mktime
from datetime import datetime, timedelta
from termcolor import colored
from os import path

import rtclient

RT_SEARCH_TIME = "%Y-%m-%d %H:%M:%S"
TICKET_TIME = '%a %b %d %H:%M:%S %Y'

class Ticket(object):
    """Describes a ticket and it's freshness"""

    adj2needs = {
                'created': 'needs update from {0.queue} POC',
                'updated': 'needs checkin from customer or {0.queue} POC',
                }

    def __init__(self, ticket_id, creds, url, states):
        self._age = None

        self.ticket_id = ticket_id
        self.ticket_dict = rtclient.get(ticket_id, creds, url)
        
        # copy the pertinent details up a level
        self.created = self.ticket_dict['Created']
        self.queue   = self.ticket_dict['Queue']
        self.status  = self.ticket_dict['Status']
        self.subject = self.ticket_dict['Subject']
        self.updated = self.ticket_dict['LastUpdated']
        
        # cast the time fields to usable types
        for timetype in ['updated', 'created']:
            time = getattr(self, timetype)
            time = mktime(strptime(time, TICKET_TIME))
            setattr(self, timetype, datetime.fromtimestamp(time))
        
        try:
            # a copy of whatever policy is applicable to this ticket's status
            self.policy = states[self.status.lower()].copy()
        except KeyError:
            self.policy = False
            logging.info("No '{0.status}' policy specified.".format(self))
        
        # what standard are we holding this ticket to?
        activity_attr, self.speeds = self.policy.popitem()
        
        # last activity is judged by the LastUpdated or Created or other attrs
        self.last_active = getattr(self, activity_attr)
        
        # and it needs?
        self.needs = self.adj2needs[activity_attr].format(self)

    def __str__(self):
        return '{0.ticket_id}: {0.subject}, {0.age}'.format(self)
    
    @property
    def age(self):
        return datetime.now() - self.last_active

    def health(self):
        """Perform some date math and return a pretty status string."""
        # what is fast and what is slow? casts config vals to time deltas
        fast, slow = [timedelta(hours=self.speeds[n])
                     for n in self.speeds.iterkeys()]

        # we aspire to be done before this goal
        goal = self.last_active + fast
        # we ought to be done before this one
        deadline = self.last_active + slow

        details = (self, deadline)

        ticktxt = colored(str(self), 'white', attrs=['bold'])
        needs = colored('{0.needs}', 'white')
        
        if deadline > datetime.now():
            status = colored("On Time {1}: ", 'green')
        else:
            needs = colored('{0.needs}', 'magenta', attrs=['underline'])
            status = colored("Overdue {1}: ", 'red')
        
        msg = status + ticktxt + ' ' + needs
        return msg.format(*details)

def check(param_path, who=False):
    """Check statuses based on the parameters file at param_path, optionally
    constrain the search to a specific user."""
    logging.debug('Opening: %s, uid=%s', param_path, who)
    with open(param_path, 'rb') as param_file:
        config = yaml.load(param_file)
  
    query = dict()

    # build the owner constraints
    if who:
        query['who'] = 'and Owner = "{}"'.format(who)
    else:
        query['who'] = ''

    # build the queue constraints
    queues = ['Queue = "{}"'.format(queue) for queue in config['queues']]
    query['queue'] = ' or '.join(queues)

    # build statuses
    skip_statuses = ['Status != "{}"'.format(status)
                    for status in config['skip_states']]
    query['skip_states'] = ' and '.join(skip_statuses)

    # get all tickets with applicable statuses from all applicable queues
    query = "{queue} and {skip_states} {who}".format(**query)
    
    logging.info('Running query: %s', query)
    for ticket in rtclient.search(query, config['creds'], config['url']):
        logging.info('Got ticket=%s subject="%s"', *ticket)
        ticket_n, _ = ticket
        aticket = Ticket(ticket_n, config['creds'], config['url'], config['states'])
        ticket_health = aticket.health()
        if ticket_health:
            print ticket_health

def main():
    """Parse args and initiate a check."""
    parser = argparse.ArgumentParser(description=__doc__)

    # default config path
    default_config = path.join(path.curdir, 'config.yaml')
    parser.add_argument('-p', '--paramfile', dest='param_path',
                        default=default_config,
                        help="Parameter file, default: %(default)s")

    parser.add_argument('-v', dest='verbosity', action='store_const',
                        const=logging.INFO, help='Verbose.')
    parser.add_argument('-vv', dest='verbosity', action='store_const',
                        const=logging.DEBUG, help='Very verbose.')

    who = parser.add_mutually_exclusive_group()
#    who.add_argument('--everyone', dest='who', action='store_false',
#        help='Check tickets owned by everyone.')
    who.add_argument('--me', dest='who', action='store_const', const=getuser(),
        help='Check tickets owned by %(const)s')
    who.add_argument('--who', dest='who', action='store', default='Nobody',
        help='Examine tickets owned by someone, default: %(default)s')
    
    args = parser.parse_args()
    
    logging.basicConfig(
        format='[%(levelname)s] %(asctime)s: %(message)s',
        level=args.verbosity
    )

    check(args.param_path, args.who)

if __name__ == "__main__":
    main()
